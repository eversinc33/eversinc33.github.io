<!doctype html><html lang=en-us><head><title>Avoiding direct syscall instructions by using trampolines // eversinc33</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.108.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="eversinc33"><meta name=description content><link rel=stylesheet href=https://eversinc33.github.io/css/main.min.56496327917020e2615871d48104da92f34d7c476ef1cb3f79a86ca13745a2ab.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Avoiding direct syscall instructions by using trampolines"><meta name=twitter:description content="Recently, in order to prepare for an internal penetration testing engagement, I wanted to automate my payload generation. In order to do so, I created a packer for executables and shellcodes called MATROJKA. Since I&rsquo;ve been a fan of Nim for malware development for some time, the choice to write my packer in Nim was an easy one. Nim has a beautiful syntax, transpiles to C, has great C and C++ (yes, real C++) integrations and is overall very fun to write in."><meta property="og:title" content="Avoiding direct syscall instructions by using trampolines"><meta property="og:description" content="Recently, in order to prepare for an internal penetration testing engagement, I wanted to automate my payload generation. In order to do so, I created a packer for executables and shellcodes called MATROJKA. Since I&rsquo;ve been a fan of Nim for malware development for some time, the choice to write my packer in Nim was an easy one. Nim has a beautiful syntax, transpiles to C, has great C and C++ (yes, real C++) integrations and is overall very fun to write in."><meta property="og:type" content="article"><meta property="og:url" content="https://eversinc33.github.io/posts/avoiding-direct-syscall-instructions/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-30T16:16:31+02:00"><meta property="article:modified_time" content="2022-08-30T16:16:31+02:00"></head><body><header class=app-header><a href=https://eversinc33.github.io><img class=app-header-avatar src="https://avatars.githubusercontent.com/u/51821028?v=4" alt=eversinc33></a><h1>eversinc33</h1><p>bits about malware development and penetration testing</p><div class=app-header-social><a href=https://github.com/eversinc33 target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>My Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/eversinc33 target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>My Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://www.linkedin.com/in/sven-rath-4212ba1b8/ target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin"><title>My linkedin</title><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Avoiding direct syscall instructions by using trampolines</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Aug 30, 2022</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>6 min read</div></div></header><div class=post-content><p>Recently, in order to prepare for an internal penetration testing engagement, I wanted to automate my payload generation. In order to do so, I created a packer for executables and shellcodes called MATROJKA. Since I&rsquo;ve been a fan of Nim for malware development for some time, the choice to write my packer in Nim was an easy one. Nim has a beautiful syntax, transpiles to C, has great C and C++ (yes, real C++) integrations and is overall very fun to write in.</p><p>There are a few publicly available packers already that are based on Nim - most notably <a href=https://github.com/chvancooten/NimPackt-v1>@chvancooten</a>&rsquo;s NimPackt-v1 packer and <a href=https://github.com/icyguider/Nimcrypt2>@icyguider</a>&rsquo;s Nimcrypt2. NimPackt-v1 is a shellcode- and dotnet-assembly packer that is <a href=https://twitter.com/blackorbird/status/1553685027753365505>actively used by threat actors in the wild</a>. It&rsquo;s second version, NimPackt-NG improves upon v1, but is, as of now, still private. Nimcrypt2 is a packer for shellcode, dotnet-assemblies and additionally supports regular portable executables.</p><p>Both NimPackt-v1 and Nimcrypt2 use SysWhispers (as implemented by <a href=https://github.com/ajpc500/NimlineWhispers2>NimlineWhispers2</a>) to invoke direct syscalls in order to avoid EDR-hooks. If you don&rsquo;t know what syscalls in Windows are, and what role they play in malware development and -detection, I can highly recommend this article by <a href=https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/>@Cn33liz</a>.</p><p>In short, syscalls are undocumented functions in <code>NTDLL.DLL</code> that are the closest to the kernel that we can get. In the end, any windows-API call calls one or more of these functions. If you for example call <code>WriteProcessMemory</code>, the syscall that is executed under the hood is <code>NtWriteVirtualMemory</code>. As such, AVs and EDRs like to hook some of these syscalls that are interesting to us malware developers, in order to inspect what is executed by a program. There are several methods to &ldquo;unhook&rdquo; these syscalls and make sure that our calls go to the kernel without being monitored - one example would be to reload a copy of <code>NTDLL.DLL</code> from disk, that is not yet hooked by the AV/EDR. Another is to find out the syscall numbers (which are different, depending on the Windows version) in some way and insert them into assembly stubs which we can be sure are not hooked, e.g. like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>r10</span>, <span style=color:#66d9ef>rcx</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>eax</span>, <span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#66d9ef>SYSCALL_NUMBER_TO_INSERT</span><span style=color:#960050;background-color:#1e0010>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># here would be where a hook would be inserted, that jumps to code that belongs to the AV/EDR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>syscall</span>   
</span></span><span style=display:flex><span><span style=color:#66d9ef>ret</span>
</span></span></code></pre></div><p>This is what SysWhispers does - it generates assembly code that is then filled with the syscall numbers depending on the version of Windows that the code is running on.</p><h2 id=detecting-direct-syscalls-made-through-syswhispers>Detecting direct syscalls made through SysWhispers</h2><p>The problem with using SysWhispers1 and SysWhispers2 (not 3 though) is that by now it is heavily signatured by most AVs and EDRs and most binaries generated with tools that leverage SysWhispers are easily flagged as malicious (I assume this is why Nimcrypt2 additionally supports using GetSyscallStub instead of NimlineWhispers2).</p><p>One simple way to detect the use of syscalls generated by SysWhispers is to check for direct <code>syscall</code> instructions. Usually, each syscall goes through <code>NTDLL.DLL</code>, which acts as Windows&rsquo; interface to kernel mode, so direct <code>syscall</code> instructions should (in theory) never occur and are highly suspicious.</p><p><img src=/objdump_syscall.png alt=Objdump></p><p>As such, Defender instantly removes a binary that includes NimlineWhispers2 (if no further evasion is applied) upon downloading it onto a Windows host:</p><p><img src=/defender.png alt=Defender></p><p>That meant that I had to look for a different way to invoke direct syscalls for my packer. I did not want to use <a href=https://github.com/S3cur3Th1sSh1t/NimGetSyscallStub/blob/main/GetSyscallStub.nim>GetSyscallStub</a>, since it is used by Nimcrypt2 and I figured that using a different technique would make my packer&rsquo;s signatures more unique and thus less detectable.</p><h2 id=retrieve-syscalls-with-hellsgate>Retrieve syscalls with HellsGate</h2><p>Another technique that is widely used to retrieve syscall numbers, in order to invoke unhooked syscalls is HellsGate by @smelly__vx and @am0nsec. You basically traverse the <a href=https://malwareandstuff.com/peb-where-magic-is-stored/><code>PEB</code> structure</a>, until you reach the module list, get <code>NTDLL.DLL</code>&rsquo;s base address and then traverse its <a href=https://dev.to/wireless90/exploring-the-export-table-windows-pe-internals-4l47><code>Export Address Table</code></a> until you find the desired function. <a href=https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware>API Hashing</a> is used to find the function name. Then, all that is left is to extract the syscall number from that function and you have everything you need to call that syscall directly, by using a syscall stub like above. You can read the paper at the <a href=https://github.com/vxunderground/VXUG-Papers/tree/main/Hells%20Gate>Vx-Underground Github</a>, which explains it more in-depth. Luckily, <a href=https://github.com/zimawhit3/HellsGateNim>zimawhit3</a> already implemented HellsGate in Nim.</p><p>However, with HellsGate the same problem arises, since the assembly stubs that are populated with the retrieved syscall numbers also use the direct <code>syscall</code> instruction to invoke the syscall.</p><h2 id=make-it-bounce>Make it bounce!</h2><p>To make my syscalls seem more legit, I adjusted HellsGate, by simply replacing all <code>syscall</code> instructions with a trampoline jump - in this case a <code>JMP</code> instruction that jumps to the location of a <code>syscall</code> instruction located in <code>NTDLL.DLL</code>. This makes the syscalls seem more legit, as they originate from <code>NTDLL.DLL</code> and also avoids leaving any <code>syscall</code> instructions in the resulting binary. This technique is nothing new though, and was described e.g. in a <a href=https://passthehashbrowns.github.io/hiding-your-syscalls>blog post by @passthehashbrowns</a>. In fact, I later found out that this is what <a href=https://klezvirus.github.io/RedTeaming/AV_Evasion/NoSysWhisper/>SysWhispers3</a> and <a href=https://github.com/klezVirus/NimlineWhispers3>NimlineWhispers3</a> ended up using as a remediation (well&mldr;). However, I still see it as a way to improve HellsGate. EDIT: I found out that this modification to HellsGate has already been done and is known as <a href=https://github.com/thefLink/RecycledGate>RecycledGate</a></p><p>Thanks to Nim&rsquo;s ability to write inline assembly, implementing this was a breeze:</p><p>First, I parsed <code>NTDLL.DLL</code> byte by byte until a <code>syscall</code> instruction is found. In binary representation, the <code>syscall</code> instruction and its prologue are <code>0x75 0x03 0x0F 0x05</code>, as can be seen when inspecting the DLL in x64dbg:</p><p><img src=/dbg.png alt=X64></p><p>Starting from the <code>NTDLL.DLL</code> module base address it doesn&rsquo;t take long for one to find such an address. We just take the first one we find and save it to the global variable <code>syscallJumpAddress</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>proc </span><span style=color:#a6e22e>getSyscallInstructionAddress</span>(ntdllModuleBaseAddr: PVOID): ByteAddress <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>## Get The address of a syscall instruction from ntdll to make sure all syscalls go through ntdll</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;[*] Resolving syscall...&#34;</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;[*] NTDDL Base: &#34;</span> <span style=color:#f92672>&amp;</span> <span style=color:#f92672>$</span><span style=color:#66d9ef>cast</span><span style=color:#f92672>[</span><span style=color:#66d9ef>int</span><span style=color:#f92672>]</span>(ntdllModuleBaseAddr).toHex
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> offset: UINT <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>true</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> currByte <span style=color:#f92672>=</span> <span style=color:#66d9ef>cast</span><span style=color:#f92672>[</span>PDWORD<span style=color:#f92672>]</span>(ntdllModuleBaseAddr <span style=color:#f92672>+</span> offset)<span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;050F0375&#34;</span> <span style=color:#f92672>in</span> <span style=color:#f92672>$</span>currByte.toHex:
</span></span><span style=display:flex><span>            echo <span style=color:#e6db74>&#34;[*] Found syscall in ntdll addr &#34;</span> <span style=color:#f92672>&amp;</span> <span style=color:#f92672>$</span><span style=color:#66d9ef>cast</span><span style=color:#f92672>[</span>ByteAddress<span style=color:#f92672>]</span>(ntdllModuleBaseAddr <span style=color:#f92672>+</span> offset).toHex <span style=color:#f92672>&amp;</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>&amp;</span> <span style=color:#f92672>$</span>currByte.toHex
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>cast</span><span style=color:#f92672>[</span>ByteAddress<span style=color:#f92672>]</span>(ntdllModuleBaseAddr <span style=color:#f92672>+</span> offset) <span style=color:#f92672>+</span> sizeof(WORD)
</span></span><span style=display:flex><span>        offset <span style=color:#f92672>=</span> offset <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>Now all that is left is to adjust the assembly code for each syscall and add a <code>JMP</code> to our address from above:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>proc </span><span style=color:#a6e22e>NtProtectVirtualMemory</span>(ProcessHandle: Handle, BaseAddress: PVOID, NumberOfBytesToProtect: PULONG, NewAccessProtection: ULONG, OldAccessProtection: PULONG): NTSTATUS {.asmNoStackFrame.} <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>asm</span> <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        mov r10, rcx
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        mov eax, `ntProtectSyscall`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        # syscall                     # this is what we want to avoid
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        mov r11, `syscallJumpAddress` # move syscall address into r11
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        jmp r11			      # jump to syscall address
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ret
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span></code></pre></div><p>When compiling the binary, we do not have any direct syscalls left anymore, which resulted in a much smaller detection rate for my packed payloads. Neat!</p><p><img src=/objdump.png alt="clean objdump"></p><p>Grabbing the first one available worked fine for me. One idea for improvement that is left is to control what <code>syscall</code> instruction we jump to and use this to e.g. fool an analyst that only observes the location of the syscall. EDIT 02/08/23: I just pushed changes that fix this. Now the <code>syscall</code> instruction that is corresponding to the actual syscall is taken instead.</p><p>The code for this technique is hosted at <a href=https://github.com/eversinc33/BouncyGate>https://github.com/eversinc33/BouncyGate</a>. Unfortunately, as opposed to SysWhispers/NimlineWhispers, you will have to add the function definitions for each Syscall that you need yourself (but you can still use those that NimlineWhispers generates).</p><p>Happy Hacking!</p></div><div class=post-footer></div></article></main></body></html>