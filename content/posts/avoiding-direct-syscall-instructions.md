---
title: "Avoiding direct syscall assembly instructions with trampolines"
date: 2022-08-30T16:16:31+02:00
draft: false
---

Recently, in order to prepare for an internal penetration testing engagement, I wanted to automate my payload generation. In order to do so, I created a packer for executables and shellcodes called MATROJKA. Since I've been a fan of Nim for malware development for some time, the choice to write my packer in Nim was an easy one. Nim has a beautiful syntax, transpiles to C, has great C and C++ (yes, real C++) integrations and is overall very fun to write in.

There are a few publicly available packers already that are based on Nim - most notably [@chvancooten](https://github.com/chvancooten/NimPackt-v1)'s NimPackt-v1 packer and [@icyguider](https://github.com/icyguider/Nimcrypt2)'s Nimcrypt2. NimPackt-v1 is a shellcode- and dotnet-assembly packer that is [actively used by threat actors in the wild](https://twitter.com/blackorbird/status/1553685027753365505). It's second version, NimPackt-NG improves upon v1, but is, as of now, still private. Nimcrypt2 is a packer for shellcode, dotnet-assemblies and additionally supports regular portable executables. 

Both NimPackt-v1 and Nimcrypt2 use SysWhispers (as implemented by [NimlineWhispers2](https://github.com/ajpc500/NimlineWhispers2)) to invoke direct syscalls in order to avoid EDR-hooks. If you don't know what syscalls in Windows are, and what role they play in malware development and -detection, I can highly recommend this article by [@Cn33liz](https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/).

## Detecting direct syscalls made through SysWhispers

The problem with using SysWhispers is that by now it is heavily signatured by most AVs and EDRs and most binaries generated with tools that leverage SysWhispers are easily flagged as malicious (I assume this is why Nimcrypt2 additionally supports using GetSyscallStub instead of NimlineWhispers2).

One simple way to detect the use of syscalls generated by SysWhispers is to check for direct `syscall` instructions. Usually, each syscall goes through `NTDLL.DLL`, which acts as Windows' interface to kernel mode, so direct `syscall` instructions should (in theory) never occur and are highly suspicious.

![Objdump](/objdump_syscall.png)

As such, Defender instantly removes a binary that includes NimlineWhispers2 (if no further evasion is applied) upon downloading it onto a Windows host:

![Defender](/defender.png)

That meant that I had to look for a different way to invoke direct syscalls for my packer. I did not want to use [GetSyscallStub](https://github.com/S3cur3Th1sSh1t/NimGetSyscallStub/blob/main/GetSyscallStub.nim), since it is used by Nimcrypt2 and I figured that using a different technique would make my packer's signatures more unique and thus less detectable.

## Retrieve syscalls with HellsGate

Another technique that is widely used to retrieve syscall numbers, in order to invoke unhooked syscalls is HellsGate by @smelly__vx and @am0nsec. You basically traverse the [`PEB` structure](https://malwareandstuff.com/peb-where-magic-is-stored/), until you reach the module list, get `NTDLL.DLL`'s base address and then traverse its [`Export Address Table`](https://dev.to/wireless90/exploring-the-export-table-windows-pe-internals-4l47) until you find the desired function. Then, all that is left is to extract the syscall number from that function and you have everything you need to call that syscall directly. You can read the paper at the [Vx-Underground Github](https://github.com/vxunderground/VXUG-Papers/tree/main/Hells%20Gate), which explains it more in-depth.

Luckily, [zimawhit3](https://github.com/zimawhit3/HellsGateNim) already implemented HellsGate in Nim, so I didn't have to port my C++ implementation to Nim. His implementation additionally uses [API Hashing](https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware). However, with HellsGate the same problem arises, since the assembly stubs that are populated with the retrieved syscall numbers also use the direct `syscall` instruction to invoke the syscall.

## Make it bounce!

To make my syscalls seem more legit, I adjusted HellsGate, by simply replacing all `syscall` instructions with a trampoline jump - in this case a `JMP` instruction that jumps to the location of a `syscall` instruction located in `NTDLL.DLL`. This makes the syscalls seem more legit, as they originate from `NTDLL.DLL` and also avoid leaving any `syscall` instructions in the resulting binary. This technique is nothing newh, and was described e.g. in a [blog post by @passthehashbrowns](https://passthehashbrowns.github.io/hiding-your-syscalls). However, I saw it as a way to improve HellsGate. And thanks to Nim's ability to write inline assembly, implementing this was a breeze:

First, I parsed `NTDLL.DLL` byte by byte until a `syscall` instruction is found. In binary representation, the `syscall` instruction and its prologue are `0x75 0x03 0x0F 0x05`, as can be seen when inspecting the DLL in x64dbg:

![X64](/dbg.png)

Starting from the `NTDLL.DLL` module base address it doesn't take long for one to find such an address. We just take the first one we find and save it to the global variable `syscallJumpAddress`:

```nim
proc getSyscallInstructionAddress(ntdllModuleBaseAddr: PVOID): ByteAddress =
    ## Get The address of a syscall instruction from ntdll to make sure all syscalls go through ntdll
    echo "[*] Resolving syscall..."
    echo "[*] NTDDL Base: " & $cast[int](ntdllModuleBaseAddr).toHex
    var offset: UINT = 0
    while true:
        var currByte = cast[PDWORD](ntdllModuleBaseAddr + offset)[]
        if "050F0375" in $currByte.toHex:
            echo "[*] Found syscall in ntdll addr " & $cast[ByteAddress](ntdllModuleBaseAddr + offset).toHex & ": " & $currByte.toHex
            return cast[ByteAddress](ntdllModuleBaseAddr + offset) + sizeof(WORD)
        offset = offset + 1

```

Now all that is left is to adjust the assembly code for each syscall and add a `JMP` to our address from above:

```nim
proc NtProtectVirtualMemory(ProcessHandle: Handle, BaseAddress: PVOID, NumberOfBytesToProtect: PULONG, NewAccessProtection: ULONG, OldAccessProtection: PULONG): NTSTATUS {.asmNoStackFrame.} =
    asm """
        mov r10, rcx
        mov eax, `ntProtectSyscall`
        # syscall                     # this is what we want to avoid
        mov r11, `syscallJumpAddress` # move syscall address into r11
        jmp r11			      # jump to syscall address
        ret
    """
```

When compiling the binary, we do not have any direct syscalls left anymore, which resulted in a much smaller detection rate for my packed payloads. Neat!

![clean objdump](/objdump.png)

The code for this technique is hosted at https://github.com/eversinc33/BouncyGate. Unfortunately, as opposed to SysWhispers/NimlineWhispers, you will have to add the function definitions for each Syscall that you need yourself (but you can still use those that NimlineWhispers generates). Happy Hacking!
